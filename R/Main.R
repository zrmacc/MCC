# -----------------------------------------------------------------------------
# Bootstrap/permutation
# -----------------------------------------------------------------------------

#' Bootstrap Inference
#' 
#' Constructs bootstrap confidence intervals.
#' 
#' @param data0 Data.frame containing `time`, `status`, `idx`, `strata` for arm 0.
#' @param data1 Data.frame containing `time`, `status`, `idx`, `strata` for arm 1.
#' @param obs_stats Observed contrasts.
#' @param tau Trunction time.
#' @param alpha Type I error.
#' @param reps Simulations replicates.
#' @param seed Simulation seed.
#' @return Data.frame containing:
#' \itemize{
#'   \item Bootstrap difference 'boot_diff' and ratio 'boot_ratio' of areas.
#'   \item An indicator that the bootstrap difference was of the opposite
#'     sign, '1side_boot_diff'.
#' }

Boot.sim <- function(
  data0,
  data1,
  obs_stats,
  tau,
  alpha,
  reps,
  seed
) {
  set.seed(seed)
  n0 <- nrow(data0)
  
  # Bootstrap function.
  loop <- function(b) {
    
    # Bootstrap data sets.
    boot0 <- StratGroupBoot(data0, idx_offset = 0)
    boot1 <- StratGroupBoot(data1, idx_offset = n0)
    
    # Bootstrap statistics.
    boot_stats <- AUC.Stats(
      data0 = boot0,
      data1 = boot1,
      tau = tau,
      alpha = alpha
    )
    names(boot_stats) <- paste0('boot_', names(boot_stats))
    
    # Bootstrap p-value indicators.
    # Indicator is 1 if the sign of the difference in areas is opposite that observed.
    is_diff_sign <- sign(boot_stats$boot_est[1]) != sign(obs_stats$est[1])
    
    # Results
    out <- c(
      boot_stats$boot_est,
      is_diff_sign
    )
    return(out)
  }
  
  sim <- lapply(seq(1:reps), loop)
  sim <- data.frame(do.call(rbind, sim))
  colnames(sim) <- c('boot_diff', 'boot_ratio', '1side_boot_diff')
  return(sim)
}


#' Bootstrap Confidence Intervals
#' 
#' @param sim Bootstrap simulation results, as generated by \code{\link{Boot.sim}}.
#' @param obs_stats Observed contrasts.
#' @param alpha Type I error.
#' @return Data.framne containing the equi-talied and highest-density bootstrap
#'   confidence intervals. 

Boot.cis <- function(
  sim,
  obs_stats,
  alpha
) {
  
  # Equi-tailed CI for difference.
  eti_diff <- HighDensCI(
    x = sim$boot_diff, 
    min_tail_prob = alpha / 2,
    intervals = 0
  )
  
  # Equi-tailed CI for ratio.
  eti_ratio <- HighDensCI(
    x = log(sim$boot_ratio),
    min_tail_prob = alpha / 2,
    intervals = 0
  )
  eti_ratio[1:2] <- exp(eti_ratio[1:2])
  
  # HDI for difference.
  reps <- nrow(sim)
  hdi_diff <- HighDensCI(
    x = sim$boot_diff,
    alpha = alpha,
    min_tail_prob = 1 / reps,
    intervals = 1e3
  )
  
  # HDI for ratio.
  hdi_ratio <- HighDensCI(
    x = log(sim$boot_ratio),
    alpha = alpha,
    min_tail_prob = 1 / reps,
    intervals = 1e3
  )
  hdi_ratio[1:2] <- exp(hdi_ratio[1:2])
  
  # Format confidence intervals. 
  cis <- data.frame(
    rbind(
      eti_diff,
      hdi_diff,
      eti_ratio,
      hdi_ratio
    )
  )
  rownames(cis) <- NULL
  colnames(cis) <- c('Lower', 'Upper', 'Lower_alpha', 'Upper_alpha')
  cis$Method <- "Bootstrap"
  cis$Type <- rep(c('Equitailed', 'Highest-density'), times = 2)
  cis$Contrast <- rep(c('A1-A0', 'A1/A0'), each = 2)
  cis$Observed <- rep(obs_stats$est, each = 2)
  col_order <- c("Method", "Type", "Contrast", "Observed",
                 "Lower", "Upper", "Lower_alpha", "Upper_alpha")
  cis <- cis[, col_order]
  return(cis)
}


# -----------------------------------------------------------------------------

#' Permutation Inference
#' 
#' @param data Data.frame containing `time`, `status`, `arm`, `idx`, `strata`.
#' @param obs_stats Observed contrasts.
#' @param tau Trunction time.
#' @param alpha Type I error.
#' @param reps Simulations replicates.
#' @param seed Simulation seed.
#' @return Data.frame containing:
#' \itemize{
#'   \item Permutation difference 'perm_diff' and ratio 'perm_ratio' of areas.
#'   \item Indicators that the permutation difference or ratio was as or more extreme
#'     than the observed difference or ratio.
#' }

CompAUCs.perm <- function(
  data,
  obs_stats,
  tau,
  alpha,
  reps,
  seed
) {
  set.seed(seed)
  
  # Permutation function.
  loop <- function(b) {
    
    # Permute data.
    perm <- PermData(data)
    perm0 <- perm[perm$arm == 0, ]
    perm1 <- perm[perm$arm == 1, ]
    
    # Permutation statistics
    perm_stats <- AUC.Stats(
      data0 = perm0,
      data1 = perm1,
      tau = tau,
      alpha = alpha
    )
    names(perm_stats) <- paste0('perm_', names(perm_stats))
    
    # Permutation indicators.
    perm_diff <- perm_stats$perm_est[1]
    obs_diff <- obs_stats$est[1]
    perm_ratio <- perm_stats$perm_est[2]
    obs_ratio <- obs_stats$est[2]
    
    sign_diff <- (sign(perm_diff) != sign(obs_diff))
    ind_2side_perm_diff <- abs(perm_diff) >= abs(obs_diff)
    ind_2side_perm_ratio <- abs(log(perm_ratio)) >= abs(log(obs_ratio))
    ind_1side_perm_diff <- sign_diff * ind_2side_perm_diff
    ind_1side_perm_ratio <- sign_diff * ind_2side_perm_ratio
    
    # Results
    out <- c(
      perm_stats$perm_est,
      '1side_perm_diff' = ind_1side_perm_diff,
      '2side_perm_diff' = ind_2side_perm_diff,
      '1side_perm_ratio' = ind_1side_perm_ratio,
      '2side_perm_ratio' = ind_2side_perm_ratio
    )
    return(out)
  }
  
  sim <- lapply(seq(1:reps), loop)
  sim <- data.frame(do.call(rbind, sim))
  colnames(sim) <- c('perm_diff', 'perm_ratio', 
                     '1side_perm_diff', '2side_perm_diff',
                     '1side_perm_ratio', '2side_perm_ratio')
  return(sim)
}

# -----------------------------------------------------------------------------
# Main function
# -----------------------------------------------------------------------------

#' Inference on the Area Under the Cumulative Count Curve
#'
#' Confidence intervals and p-values for the difference and ratio of areas under
#' the mean cumulative count curves, comparing treatment (arm = 1) with
#' reference (arm = 0).
#' 
#' Two methods of p-value calculation are available. For 'perm', treatment 
#' assignments are permuted on each iteration, and the p-value is the
#' proportion of the *null* statistics that are as or more extreme than
#' the *observed* statistics. For 'boot', the p-value is twice the proportion
#' of bootstrap replicates on which the sign of the difference is areas is 
#' reversed. 
#' 
#' @param time Observation time.
#' @param status Status, coded as 0 for censoring, 1 for event, 2 for death. 
#'   Note that subjects who are neither censored nor die are assumed to
#'   remain at risk throughout the observation period. 
#' @param arm Arm, coded as 1 for treatment, 0 for reference. 
#' @param idx Unique subject index. 
#' @param tau Truncation time. 
#' @param strata Optional stratification factor. 
#' @param alpha Alpha level.
#' @param boot Logical, construct bootstrap confidence intervals?
#' @param perm Logical, perform permutation test?
#' @param reps Replicates for bootstrap/permutation inference.
#' @param seed Seed for bootstrap/permutation inference.
#' @importFrom stats quantile 
#' @importFrom methods new
#' @export 
#' @return Object of class compAUCs with these slots:
#' \itemize{
#'   \item `@Areas`: The AUC for each arm.
#'   \item `@CIs`: Observed difference and ratio in areas with confidence intervals. 
#'   \item `@Curves`: Mean cumulative count curve for each arm; averaged across strata 
#'     if present. 
#'   \item `@Pvals`: Bootstrap and permutation p-values.
#'   \item `@Reps`: Bootstrap and permutation realizations of the test statistics. 
#'   \item `@Weights`: Per-stratum weights and AUCs. 
#' }
#' @examples 
#' \donttest{
#' # Simulate data set.
#' data1 <- GenData(
#'   n = 100,
#'   censoring_rate = 0.25,
#'   event_rate = 1,
#'   death_rate = 0.25,
#'   tau = 10
#' )
#' data1$arm <- 1
#' 
#' data0 <- GenData(
#'   n = 100,
#'   censoring_rate = 0.25,
#'   event_rate = 2,
#'   death_rate = 0.25,
#'   tau = 10
#' )
#' data0$arm <- 0
#' data0$idx <- data0$idx + 100
#' 
#' data <- rbind(data1, data0)
#' 
#' aucs <- CompareAUCs(
#'   time = data$time,
#'   status = data$status,
#'   arm = data$arm,
#'   idx = data$idx,
#'   tau = 2,
#'   boot = TRUE,
#'   perm = TRUE,
#'   reps = 100,
#'   alpha = 0.05
#' )
#' show(aucs)
#' }

CompareAUCs <- function(
  time, 
  status, 
  arm, 
  idx, 
  tau, 
  strata = NULL,
  alpha = 0.05,
  boot = FALSE,
  perm = FALSE,
  reps = 2000, 
  seed = 100
) { 
  
  # Create single stratum if no strata are provided. 
  if (is.null(strata)){
    strata <- rep(1, length(time))
  }
  
  # Form data.
  data <- data.frame(time, status, arm, idx, strata)
  data$strata <- factor(data$strata)
  
  # Split data. 
  data0 <- data[data$arm == 0, ]
  data1 <- data[data$arm == 1, ]
  
  # Observed test stats.
  obs <- AUC.Stats(
    data0 = data0,
    data1 = data1,
    tau = tau, 
    alpha = alpha,
    return_areas = TRUE
  ) 
  obs_stats <- obs$contrasts
  
  # CIs.
  cis <- obs_stats[, c(1:4)]
  colnames(cis) <- c("Contrast", "Observed", "Lower", "Upper")
  cis <- cbind(
    "Method" = "Asymp",
    "Type" = "Equitailed",
    cis,
    "Lower_alpha" = alpha / 2,
    "Upper_alpha" = alpha / 2
  )
  
  # P-values.
  pvals <- obs_stats[, c(1:2, 5)]
  colnames(pvals) <- c("Contrast", "Observed", "P")
  pvals <- cbind(
    "Method" = "Asymp",
    "Sides" = 2,
    pvals
  )
  
  # Simulation replicates.
  sim_reps <- list()
  
  # -------------------------------------------------------
  
  # Bootstrap inference.
  if (boot) {
    
    # Simulate.
    boot_sim <- Boot.sim(
      data0 = data0,
      data1 = data1,
      obs_stats = obs_stats,
      tau = tau,
      alpha = alpha,
      reps = reps,
      seed = seed
    )
    sim_reps$boot_sim <- boot_sim
    
    # Confidence intervals.
    boot_cis <- Boot.cis(
      sim = boot_sim,
      obs_stats = obs_stats,
      alpha = alpha
    )
    cis <- rbind(
      cis,
      boot_cis
    )
    
    # P-value.
    boot_p <- mean(boot_sim$`1side_boot_diff`)
    boot_pvals <- cbind(
      "Method" = "Bootstrap",
      "Sides" = 1,
      pvals[, c("Contrast", "Observed")],
      "P" = boot_p
    )
    pvals <- rbind(
      pvals,
      boot_pvals
    )
    
  }
  
  # -------------------------------------------------------
  
  # Permutation inference.
  if (perm) {
    
    # Simulate.
    perm_sim <- CompAUCs.perm(
      data = data,
      obs_stats = obs_stats,
      tau = tau,
      alpha = alpha,
      reps = reps,
      seed = seed
    )
    sim_reps$perm_sim <- perm_sim
    
    # Permutation p-values.
    perm_pvals <- data.frame(
      'Method' = "Perm",
      'Sides' = rep(c(1, 2), times = 2),
      'Contrast' = rep(c('A1-A0', 'A1/A0'), each = 2),
      'Observed' = rep(obs_stats$est, each = 2),
      'P' = apply(perm_sim[, 3:6], 2, mean)
    )
    rownames(perm_pvals) <- NULL
    pvals <- rbind(
      pvals,
      perm_pvals
    )
    
  }
  
  # -------------------------------------------------------
  
  # Output
  out <- new(
    Class = 'compAUCs',
    StratumAreas = obs$stratum_areas,
    MargAreas = obs$marg_areas,
    CIs = cis,
    MCF = obs$avg_mcf,
    Reps = sim_reps,
    Pvals = pvals,
    Weights = obs$weights
  )
  
  return(out)
}

